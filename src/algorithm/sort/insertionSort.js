/**
 * NOTE: 插入排序：在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置（类似于整理扑克牌）
 * @param {Number[]} nums 待排序的数组
 */
function insertionSort(nums) {
  // 外循环： n - 1 次
  for (let i = 1; i < nums.length; ++i) {
    let j = i - 1,
      base = nums[i]
    // 内循环：最佳 0 次，最差 i 次
    while (j >= 0 && base < nums[j]) {
      nums[j + 1] = nums[j]
      j--
    }
    nums[j + 1] = base
  }
  return nums
}

/**
 * 复杂度分析：
 * 时间：O(n^2)。
 * 最差和平均复杂度计算：外循环一共 n - 1 次，内循环对未排序数组进行循环求极值，第一轮 1 次，最后一轮 n - 1 次，求和为 n * (n - 1) / 2
 * 最佳复杂度：当数组本身已按照规则排好序时，复杂度可将至 O(n)
 * 空间：O(1)。原地排序，指针消耗常数大小额外空间。
 *
 * 稳定排序：在插入操作过程中，我们会将元素插入到相等元素的右侧，不会改变它们的顺序。
 */

/**
 * 横向比较：
 * 1. 与选择和冒泡相比，三者时间复杂度均为O(n^2)，但前两者的单元操作数为3（swap），而插入排序基于元素赋值实现，单位操作数为1，相对具有一定的优势。
 * 2. 与选择排序相比，在数据本身排好序的情况下，时间复杂度上，冒泡和插入排序可优化为 O(n)。
 *
 * 综合来看，插入排序适用于数据量较小时的排序。
 */

// console.log(insertionSort([4, 1, 3, 1, 5, 2]))
console.log(insertionSort([25, 32, 4, 1, 34, 10, 51, 29]))
